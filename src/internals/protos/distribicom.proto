syntax = "proto3";
// Namespace
package distribicom;


// all services assumes configs: (DistribicomConfigs)
service Worker {// anyone who wishes to work runs this services.
  /*
    Send task is a stream that runs each round until all information in regards to the task is done.
    The manager initialize the stream once the round begins, and pushes all ctxs and ptxs the worker should
    use in the mat-mul operation.
    once the server is done sending the data, it should close the stream.

    Metadata, like round number ETC should be sent inside the stream context.
   */
  rpc SendTask(stream WorkerTaskPart) returns (Ack){};
}


// facing workers, pub/sub of work that should be done.
service Manager {// masterServer runs this service.

  // PartialWorkStream i save this on my server map.
  rpc RegisterAsWorker(WorkerRegistryRequest) returns (Ack){};

  // a worker should send its work, along with credentials of what it sent.
  rpc ReturnLocalWork(stream MatrixPart) returns (Ack){};
}


service Client{// anyone who owns a query need to run a listener for this service.
  // once the round ends, and the server has an answer it should call upon this RPC call and send the answer
  //  to the client
  rpc Answer(Ciphertext) returns (Ack){};
  rpc TellNewRound(TellNewRoundRequest) returns (Ack){};
}

// facing clients, allowing them to read and write to the server.
service Server {// masterServer runs this service.
  /*
  Assumes this cannot be called in the middle of a round.

  We assume this connection is performed with a TLS secured channel to the server.

   Upon receiving this call, the server should create a Client instance so it'll be able to answer the client
   using the `Answer` RPC call once the round is over.
   Should contact this given client according to its IP.
   Should contact the client with MAC with a MAC using the clients given request key.

   Once the client is done sending to the server, it should close the connection.
   */
  rpc StoreQuery(ClientQueryRequest) returns (Ack){};
  /*
    Anyone can write to the DB, on an unsecured channel.
    Need to avoid malicious users from writing to all cells in the DB.
    the server must ensure any writing is done once per
    client though. (TODO: think of the proper way to do that in our system).
   */
  rpc WriteToDB(WriteRequest) returns (Ack){};
}


message Ack{
  bool success = 1; // states whether the client received all messages correctly.
}
message WorkerTaskPart {
  oneof part {
    MatrixPart matrixPart = 1;
    GaloisKeys gkey = 3;
  }
}
message MatrixPart {
  oneof data{
    Ciphertext ctx = 1;
    Plaintext ptx = 2;
  }

  int32 row = 3;
  int32 col = 4;
}

message QueryCiphertext{
  bytes data = 1;
  bytes GaloisKeyElem = 2;
}
message GaloisKeys{
  bytes keys = 1;
  // should point to the matching ciphertext.
}
message Ciphertext{bytes data = 1;}

message Plaintext{bytes data = 1;}
// small:
message WriteRequest{
  // todo: should it be stated as row,col,ptx-part in the DB's matrix? I think it is easier to work like that...
  int64 ptxnumber = 1;
  int32 whereinptx = 2;
  bytes data = 3; // 288 bytes?
};

message ClientQueryRequest{
  oneof payload{
    bytes GaloisKeyElem = 1;
    bytes ctx = 3;
  }
}

message TellNewRoundRequest{
  int32 round = 1;
}

message WorkerRegistryRequest{
  // should be used to ensure the worker knows the messages are legitimate from the server.
  bytes credentials = 1;

  // the port the worker is listening to.
  uint32  workerPort = 2;
}

// Every subscriber should have a certificate it created to ensure the connections from the server
// are secure
message Subscriber{
  // TODO consider how to use. probably only need the sym_key.
  bytes secretKey = 1;
  bytes publicKey = 2;
  bytes sym_key = 3;
}



/// configurations:

message Configs {
  // encryption params
  string scheme = 1;
  uint32 polynomial_degree = 2;
  uint32 logarithm_plaintext_coefficient = 3;

  // for PIR params
  uint32 db_rows = 4;
  uint32 db_cols = 5;
  uint32 size_per_element = 6; // element represents a position inside the plaintext that a user can write to.
  uint32 dimensions = 7; // in our case defaults eqauls to 2.
};

message AppConfigs{
  Configs configs = 1;

  //every worker/ client will need to register to the following address:
  string main_server_hostname = 2;
  bytes main_server_cert = 3; // TODO: use for TLS connection.
};

message WorkerConfigs{
  AppConfigs appConfigs = 1;

  // the port the worker is listening to.
  uint32  workerPort = 2;
};